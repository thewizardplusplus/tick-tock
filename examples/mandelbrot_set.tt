actor PointGenerator()
  state __initialization__()
    message generate_point(dimensions, point)
      let point = point || { x: 0, y: 0 }
      send point_generated(dimensions, point)

      let index = dimensions.width * point.y + point.x
      let progress = index / (dimensions.width * dimensions.height)
      send point_generation_progress(progress)

      set point_serialization_waiting(dimensions, point)
    ;
  ;

  state point_serialization_waiting(dimensions, point)
    message point_serialized()
      set __initialization__()

      let point = when
        => point.x != dimensions.width - 1
          { x: point.x + 1, y: point.y }
        => true
          when
            => point.y != dimensions.height - 1
              { x: 0, y: point.y + 1 }
            => true
              return
          ;
      ;
      send generate_point(dimensions, point)
    ;
  ;
;

actor Render()
  state __initialization__()
    message point_generated(dimensions, point)
      let real_range = { minimum: -2, maximum: 1 }
      let imaginary_range = { minimum: -1, maximum: 1 }
      let x_step = (real_range.maximum - real_range.minimum) / dimensions.width
      let y_step = (imaginary_range.maximum - imaginary_range.minimum) / dimensions.height
      let origin_point = {
        x: point.x * x_step + real_range.minimum,
        y: point.y * y_step + imaginary_range.minimum,
      }
      send search_escape(dimensions, 100, origin_point, origin_point, 0)
    ;

    message search_escape(dimensions, maximal_iteration, origin_point, point, iteration)
      when
        => pow(point.x, 2) + pow(point.y, 2) > 4 || iteration == maximal_iteration
          let color_channel = 1 - iteration / maximal_iteration
          let color = { red: color_channel, green: color_channel, blue: color_channel }
          send pixel_generated(dimensions, point, color)

          return
      ;

      let point = {
        x: pow(point.x, 2) - pow(point.y, 2) + origin_point.x,
        y: 2 * point.x * point.y + origin_point.y,
      }
      send search_escape(dimensions, maximal_iteration, origin_point, point, iteration + 1)
    ;
  ;
;

actor PpmSerializer()
  state __initialization__(header_outed)
    message pixel_generated(dimensions, point, color)
      let maximal_color = 255
      when
        => !header_outed
          outln("P3")
          outln(str(dimensions.width) + " " + str(dimensions.height))
          outln(str(maximal_color))

          set __initialization__(true)
      ;

      let color = {
        red: round(maximal_color * color.red),
        green: round(maximal_color * color.green),
        blue: round(maximal_color * color.blue),
      }
      outln(str(color.red) + " " + str(color.green) + " " + str(color.blue))

      send point_serialized()
    ;
  ;
;

actor Main()
  state __initialization__()
    message __initialize__()
      let width = num(env("WIDTH") || "320")
      when
        => width == nil
          errln("Error: unable to parse the width.")
          return
      ;

      let height = num(env("HEIGHT") || "240")
      when
        => height == nil
          errln("Error: unable to parse the height.")
          return
      ;

      let dimensions = { width: width, height: height }
      send generate_point(dimensions)
    ;

    message point_generation_progress(progress)
      let progress = round(100 * progress)
      err("\rdone by " + str(progress) + "%")
    ;
  ;
;
