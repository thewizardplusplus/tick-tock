actor PointGenerator()
  state __initialization__()
    message generate_point(settings, point)
      let point = point || { x: 0, y: 0 }
      send point_generated(settings, point)

      let index = settings.dimensions.width * point.y + point.x
      let progress = index / (settings.dimensions.width * settings.dimensions.height)
      send point_generation_progress(progress)

      set point_serialization_waiting(settings, point)
    ;
  ;

  state point_serialization_waiting(settings, point)
    message point_serialized()
      set __initialization__()

      let point = when
        => point.x != settings.dimensions.width - 1
          { x: point.x + 1, y: point.y }
        => true
          when
            => point.y != settings.dimensions.height - 1
              { x: 0, y: point.y + 1 }
            => true
              return
          ;
      ;
      send generate_point(settings, point)
    ;
  ;
;

actor Render()
  state __initialization__()
    message point_generated(settings, point)
      let x_step = (settings.real_range.maximum - settings.real_range.minimum)
        / settings.dimensions.width
      let y_step = (settings.imaginary_range.maximum - settings.imaginary_range.minimum)
        / settings.dimensions.height
      let settings = with(settings, "origin_point", {
        x: point.x * x_step + settings.real_range.minimum,
        y: point.y * y_step + settings.imaginary_range.minimum,
      })
      send search_escape(settings, settings.origin_point, 0)
    ;

    message search_escape(settings, point, iteration)
      when
        => pow(point.x, 2) + pow(point.y, 2) > 4 || iteration == settings.maximal_iteration
          let color_channel = 1 - iteration / settings.maximal_iteration
          let color = { red: color_channel, green: color_channel, blue: color_channel }
          send pixel_generated(settings, point, color)

          return
      ;

      let point = {
        x: pow(point.x, 2) - pow(point.y, 2) + settings.origin_point.x,
        y: 2 * point.x * point.y + settings.origin_point.y,
      }
      send search_escape(settings, point, iteration + 1)
    ;
  ;
;

actor PpmSerializer()
  state __initialization__(header_outed)
    message pixel_generated(settings, point, color)
      let maximal_color = 255
      when
        => !header_outed
          outln("P3")
          outln(str(settings.dimensions.width) + " " + str(settings.dimensions.height))
          outln(str(maximal_color))

          set __initialization__(true)
      ;

      let color = {
        red: round(maximal_color * color.red),
        green: round(maximal_color * color.green),
        blue: round(maximal_color * color.blue),
      }
      outln(str(color.red) + " " + str(color.green) + " " + str(color.blue))

      send point_serialized()
    ;
  ;
;

actor Main()
  state __initialization__()
    message __initialize__()
      let width = num(env("WIDTH") || "320")
      when
        => width == nil
          errln("Error: unable to parse the width.")
          return
      ;

      let height = num(env("HEIGHT") || "240")
      when
        => height == nil
          errln("Error: unable to parse the height.")
          return
      ;

      send generate_point({
        dimensions: { width: width, height: height },
        real_range: { minimum: -2, maximum: 1 },
        imaginary_range: { minimum: -1, maximum: 1 },
        maximal_iteration: 100,
      })
    ;

    message point_generation_progress(progress)
      let progress = round(100 * progress)
      err("\rdone by " + str(progress) + "%")
    ;
  ;
;
